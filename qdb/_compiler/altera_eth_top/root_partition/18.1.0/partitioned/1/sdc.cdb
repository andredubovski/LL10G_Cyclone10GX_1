22 serialization::archive 13 0 0 0 0 3 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 0 0 9 0 0 0 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 15 address_decoder 23 address_decoder_channel 27 altera_reset_controller_181 5 synth 27 altera_reset_controller.sdc 1637 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 15 address_decoder 29 address_decoder_multi_channel 27 altera_reset_controller_181 5 synth 27 altera_reset_controller.sdc 1637 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 15 address_decoder 19 address_decoder_top 27 altera_reset_controller_181 5 synth 27 altera_reset_controller.sdc 1637 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 11 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 15 address_decoder 2 ip 19 address_decoder_top 44 address_decoder_top_mm_clock_crossing_bridge 42 altera_avalon_mm_clock_crossing_bridge_181 5 synth 25 altera_avalon_dc_fifo.sdc 4884 # $File: //acds/rel/18.1/ip/sopc/components/altera_avalon_dc_fifo/altera_avalon_dc_fifo.sdc $
# $Revision: #2 $
# $Date: 2018/08/03 $
# $Author: kknagar $

#-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to less than one launch clock period to keep the gray encoding, 
# and to minimize latency on the pointer crossings.
#
# The paths are from the Gray Code read and write pointers to their respective synchronizer banks.
#
# *** Important note *** 
#
# Do not declare the FIFO clocks as asynchronous at the top level, or false path these crossings,
# because that will override these constraints.
#-------------------------------------------------------------------------------
set all_dc_fifo [get_entity_instances altera_avalon_dc_fifo]

set_max_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_max_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|in_wr_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 
set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|out_rd_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}]


foreach dc_fifo_inst $all_dc_fifo {
   if { [ llength [query_collection -report -all [get_registers $dc_fifo_inst|in_wr_ptr_gray[*]]]] > 0  } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|in_wr_ptr_gray[*]] -to [get_registers $dc_fifo_inst|write_crosser|sync[*].u|din_s1] 
   }

   if { [ llength [query_collection -report -all [get_registers $dc_fifo_inst|out_rd_ptr_gray[*]]]] > 0 } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|out_rd_ptr_gray[*]] -to [get_registers $dc_fifo_inst|read_crosser|sync[*].u|din_s1] 
   }
}


# add in timing constraints across asynchronous clock domain crossings for simple dual clock memory inference

set mem_regs [get_registers -nowarn *|altera_avalon_dc_fifo:*|mem*];
if {![llength [query_collection -report -all $mem_regs]] > 0} {
    set mem_regs [get_registers -nowarn altera_avalon_dc_fifo:*|mem*];
}

set internal_out_payload_regs [get_registers -nowarn *|altera_avalon_dc_fifo:*|internal_out_payload*];
if {![llength [query_collection -report -all $internal_out_payload_regs]] > 0} {
    set internal_out_payload_regs [get_registers -nowarn altera_avalon_dc_fifo:*|internal_out_payload*];
}

if {[llength [query_collection -report -all $internal_out_payload_regs]] > 0 && [llength [query_collection -report -all $mem_regs]] > 0} {
    set_max_delay -from $mem_regs -to $internal_out_payload_regs 200
    set_min_delay -from $mem_regs -to $internal_out_payload_regs -200

    set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from $mem_regs -to $internal_out_payload_regs

    #set_max_skew 2 -from $mem_regs -to $internal_out_payload_regs
}

# -----------------------------------------------------------------------------
# This procedure constrains the skew between the pointer bits, and should
# be called from the top level SDC, once per instance of the FIFO.
#
# The hierarchy path to the FIFO instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_altera_avalon_dc_fifo_ptr_skew { path } {

    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|in_wr_ptr_gray\[*\] ] -to [ get_registers $path|write_crosser|sync\[*\].u|din_s1 ]
    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|out_rd_ptr_gray\[*\] ] -to [ get_registers $path|read_crosser|sync\[*\].u|din_s1 ]

}
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 18 jtag_avalon_master 19 alt_jtag_csr_master 28 altera_jtag_dc_streaming_181 5 synth 35 altera_avalon_st_jtag_interface.sdc 912 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 18 jtag_avalon_master 19 alt_jtag_csr_master 27 altera_reset_controller_181 5 synth 27 altera_reset_controller.sdc 1637 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 3 mac 15 alt_usxgmii_mac 15 alt_em10g32_181 5 synth 27 altera_reset_controller.sdc 1637 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 3 mac 15 alt_usxgmii_mac 15 alt_em10g32_181 5 synth 28 low_latency_10G_ethernet.sdc 34202 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# CORE_PARAMETERS
set DATAPATH_OPTION 3
set PREAMBLE_PASSTHROUGH 0
set ENABLE_PFC 0
set PFC_PRIORITY_NUMBER 8
set ENABLE_SUPP_ADDR 1
set ENABLE_TIMESTAMPING 0
set INSERT_ST_ADAPTOR 1
set INSERT_XGMII_ADAPTOR 0
set USE_ASYNC_ADAPTOR 0
set ENABLE_UNIDIRECTIONAL 0
set ENABLE_1G10G_MAC 5

set old_mode [set_project_mode -get_mode_value always_show_entity_name] 
set_project_mode -always_show_entity_name on

# Function to constraint non-std_synchronizer path
proc alt_em10g32_constraint_net_delay {from_reg to_reg max_net_delay} {
    
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        set_max_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] 200ns
        set_min_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] -200ns
    } else {
       # Relax the fitter effort
        set_net_delay -from [get_pins -compatibility_mode ${from_reg}|q] -to [get_registers ${to_reg}] -max $max_net_delay
    
       
        set_max_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] 200ns
        set_min_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] -200ns
    }
    
}

# Function to constraint std_synchronizer
proc alt_em10g32_constraint_std_sync {} {
    
    alt_em10g32_constraint_net_delay  *  *alt_em10g32:*|alt_em10g32_std_synchronizer:*|din_s1  2.7ns
    
}

# Function to constraint pointers
proc alt_em10g32_constraint_ptr {from_path from_reg to_path to_reg max_skew max_net_delay} {
    
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${from_path}|${from_reg}\[0\]]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${from_path}|${from_reg} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${from_path}|${from_reg} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
        foreach_in_collection each_inst_tmp $inst {
            set each_inst [get_node_info -name $each_inst_tmp] 
				#regsub {\\} $each_inst_name {*} each_inst

            # Get the path to instance
            regexp "(.*${from_path})(.*|)(${from_reg})" $each_inst reg_path inst_path inst_name reg_name
            
            set_max_skew -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] $max_skew
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -200ns
        }
        
    } else {
    
        set inst [get_registers -nowarn *${from_path}|${from_reg}\[0\]]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${from_path}|${from_reg} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${from_path}|${from_reg} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances

        # set TQ2 [get_global_assignment -name TIMEQUEST2]
        # if { $TQ2 == "ON"} {
            # foreach_in_collection each_inst_tmp $inst {
                # set each_inst [get_node_info -name $each_inst_tmp] 
                # #regsub {\\} $each_inst_name {*} each_inst
                # # Get the path to instance
                # regexp "(.*${from_path})(.*|)(${from_reg})" $each_inst reg_path inst_path inst_name reg_name
                
                # set_max_skew -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] $max_skew
                
            # }
        # }
    
        set_net_delay -from [get_pins -compatibility_mode *${from_path}|${from_reg}[*]|q] -to [get_registers *${to_path}|${to_reg}*] -max $max_net_delay
    
        
        # Relax the fitter effort
        set_max_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 200ns
        set_min_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -200ns
    }
    
}

# Function to constraint clock crosser
proc alt_em10g32_constraint_clock_crosser {} {
    set module_name alt_em10g32_clock_crosser
    
    set from_reg1 in_data_toggle
    set to_reg1 altera_std_synchronizer_nocut:synchronizer_nocut_forward_sync|din_s1
    
    set from_reg2 in_data_buffer
    set to_reg2 out_data_buffer
    
    set from_reg3 out_data_toggle_flopped
    set to_reg3 altera_std_synchronizer_nocut:synchronizer_nocut_backward_sync|din_s1
    
    set max_skew 3ns
    
    set max_delay1 3ns
    set max_delay2 2.7ns
    set max_delay3 3ns
    
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${module_name}:*|${from_reg1}]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${module_name} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${module_name} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
		foreach_in_collection each_inst_tmp $inst {
            set each_inst [get_node_info -name $each_inst_tmp] 
            #regsub {\\} $each_inst_name {*} each_inst
            # Get the path to instance
            regexp "(.*${module_name})(:.*|)(${from_reg1})" $each_inst reg_path inst_path inst_name reg_name
            
            # Check if unused data buffer get synthesized away
            set reg2_collection [get_registers -nowarn ${inst_path}${inst_name}${to_reg2}[*]]
            set reg2_num [llength [query_collection -report -all $reg2_collection]]

            if {$reg2_num > 0} {
                set_max_skew -from [get_registers "${inst_path}${inst_name}${from_reg1} ${inst_path}${inst_name}${from_reg2}[*]"] -to [get_registers "${inst_path}${inst_name}${to_reg1} ${inst_path}${inst_name}${to_reg2}[*]"] $max_skew
                
                set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] 200ns
                set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] -200ns
            }
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] -200ns
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg3}] -to [get_registers ${inst_path}${inst_name}${to_reg3}] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg3}] -to [get_registers ${inst_path}${inst_name}${to_reg3}] -200ns
        }
        
    } else {
    
			set inst [get_registers -nowarn *${module_name}:*|${from_reg1}]
        
			# Check number of instances
			set inst_num [llength [query_collection -report -all $inst]]
			if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${module_name} instance(s) found"
			} else {
            # Uncomment line below for debug purpose
            #puts "No ${module_name} instance found"
			}
        
			
            
            # set TQ2 [get_global_assignment -name TIMEQUEST2]
            # if { $TQ2 == "ON"} {
                # # Constraint one instance at a time to avoid set_max_skew apply to all instances
                # foreach_in_collection each_inst_tmp $inst {
                    # set each_inst [get_node_info -name $each_inst_tmp] 
                    # #regsub {\\} $each_inst_name {*} each_inst
                    # # Get the path to instance
                    # regexp "(.*${module_name})(:.*|)(${from_reg1})" $each_inst reg_path inst_path inst_name reg_name
            
                    # # Check if unused data buffer get synthesized away
                    # set reg2_collection [get_registers -nowarn ${inst_path}${inst_name}${to_reg2}[*]]
                    # set reg2_num [llength [query_collection -report -all $reg2_collection]]
                    # if {$reg2_num > 0} {
                        # set_max_skew -from [get_registers "${inst_path}${inst_name}${from_reg1} ${inst_path}${inst_name}${from_reg2}[*]"] -to [get_registers "${inst_path}${inst_name}${to_reg1} ${inst_path}${inst_name}${to_reg2}[*]"] $max_skew
                
                    # }
                # }	
            
            # } else {

            # }
            
	 
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg1}|q]    -to [get_registers *${module_name}:*|${to_reg1}] -max $max_delay1
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg2}[*]|q] -to [get_registers *${module_name}:*|${to_reg2}[*]] -max $max_delay2
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg3}|q]    -to [get_registers *${module_name}:*|${to_reg3}] -max $max_delay3
    
        
        # Relax the fitter effort
        set_max_delay -from [get_registers *${module_name}:*|${from_reg1}] -to [get_registers *${module_name}:*|${to_reg1}] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg1}] -to [get_registers *${module_name}:*|${to_reg1}] -200ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] -200ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg3}] -to [get_registers *${module_name}:*|${to_reg3}] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg3}] -to [get_registers *${module_name}:*|${to_reg3}] -200ns
    }
    
}

# Standard Synchronizer
alt_em10g32_constraint_std_sync

# Clock Crosser
alt_em10g32_constraint_clock_crosser

# always
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|pri_macaddr_bit31to0[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|pri_macaddr_bit31to0[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|pri_macaddr_bit47to32[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|pri_macaddr_bit47to32[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]

# Reset 
# Async reset
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_em10g32_clk_rst:clk_rst_inst*|altera_reset_synchronizer_int_chain*|clrn]

# Sync reset
set_false_path -to [get_registers *|alt_em10g32_clk_rst:clk_rst_inst*|altera_reset_synchronizer_int_chain[0]]

# false path from speed_sel during multi speed mode
if {$ENABLE_1G10G_MAC != 0 } {
    
	set_false_path -from [get_registers {*alt_em10g32unit:alt_em10g32unit_inst|speed_sel_int_sync_tx_reg2[*]}] -to *
	if {$ENABLE_1G10G_MAC != 5 } {
		set_false_path -from [get_registers {*alt_em10g32unit:alt_em10g32unit_inst|speed_sel_int_sync_rx_reg2[*]}] -to *
    }
}

# DC FIFO
if {[expr ($INSERT_ST_ADAPTOR == 1)] || ([expr ($INSERT_XGMII_ADAPTOR == 1)] && [expr ($USE_ASYNC_ADAPTOR == 1)])} {
    alt_em10g32_constraint_ptr  alt_em10g32_avalon_dc_fifo:*  in_wr_ptr_gray  alt_em10g32_avalon_dc_fifo:*|alt_em10g32_dcfifo_synchronizer_bundle:write_crosser|*  din_s1  3ns  2.7ns
    alt_em10g32_constraint_ptr  alt_em10g32_avalon_dc_fifo:*  out_rd_ptr_gray  alt_em10g32_avalon_dc_fifo:*|alt_em10g32_dcfifo_synchronizer_bundle:read_crosser|*  din_s1  3ns  2.7ns
    
    if {[expr ($INSERT_XGMII_ADAPTOR == 1)] && [expr ($USE_ASYNC_ADAPTOR == 1)] && [expr ($ENABLE_TIMESTAMPING == 1)]} {
        alt_em10g32_constraint_ptr  alt_em10g32_avalon_dc_fifo_lat_calc:*  wr_ptr_sample  alt_em10g32_avalon_dc_fifo_lat_calc:*|alt_em10g32_dcfifo_synchronizer_bundle:wr_crosser|*  din_s1  3ns  2.7ns
        alt_em10g32_constraint_ptr  alt_em10g32_avalon_dc_fifo_lat_calc:*  rd_ptr_sample  alt_em10g32_avalon_dc_fifo_lat_calc:*|alt_em10g32_dcfifo_synchronizer_bundle:rd_crosser|*  din_s1  3ns  2.7ns
        
        set_multicycle_path -from [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*transfer_valid_slow[0]}] -to [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*transfer_valid_fast[0]}] -setup -end 2
        set_multicycle_path -from [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*transfer_valid_slow[0]}] -to [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*transfer_valid_fast[0]}] -hold -end 1
        
        set_multicycle_path -from [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*xgmii_tx_path_latency_slow[*]}] -to [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*xgmii_tx_path_latency_fast[*]}] -setup -end 2
        set_multicycle_path -from [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*xgmii_tx_path_latency_slow[*]}] -to [get_registers {*alt_em10g32*alt_em10g_32_64_xgmii_conversion*alt_em10g_dcfifo_32_to_64_xgmii_conversion:tx_dcfifo_xgmii_conversion*xgmii_tx_path_latency_fast[*]}] -hold -end 1
    }
}


#enable tx
if {[expr ($DATAPATH_OPTION == 1)] || [expr ($DATAPATH_OPTION == 3)]} {


set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pad_insrt_en}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_crc_insrt_en}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_sa_override_en}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_max_datafrmlen[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|txvlandet_dis}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pipg10g_dic[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pipg1g_fixed[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pausefrm_pqt[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pausefrm_xoff_hqt[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pausefrm_en}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pausefrm_policy[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]

    # Avalon-ST Adaptor
    if {[expr ($INSERT_ST_ADAPTOR == 1)]} {
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_adptdcff_rdwtrmrk_dis}] -to [get_registers {*alt_em10g32*altera_eth_avalon_st_adapter:st_adpt.avalon_st_adpt_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_adptdcff_rdwtrmrk[*]}] -to [get_registers {*alt_em10g32*altera_eth_avalon_st_adapter:st_adpt.avalon_st_adpt_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_adptdcff_vldpkt_minwt[*]}] -to [get_registers {*alt_em10g32*altera_eth_avalon_st_adapter:st_adpt.avalon_st_adpt_inst|*}]
    }
    
    #enable tx & preamble 
    if {[expr ($PREAMBLE_PASSTHROUGH == 1)]} {
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_preamb_passthru_en}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
    }
    
    # Unidirectional constraint
    if {[expr ($ENABLE_UNIDIRECTIONAL == 1)]} {
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_unidirectional_en}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_unidirectional_remote_fault_dis}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
	set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_unidirectional_force_remote_fault}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]

	}

    if {[expr ($ENABLE_PFC == 1)]} {
    
        if {[expr ($PFC_PRIORITY_NUMBER >= 2)]} {
        #enable tx + enable pfc + pfc num >0
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en0}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt0[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt0[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        #enable tx + enable pfc + pfc num >1
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en1}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt1[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt1[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 3)]} {
        #enable tx + enable pfc + pfc num >2
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en2}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt2[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt2[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}] 
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 4)]} {
        #enable tx + enable pfc + pfc num >3
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en3}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt3[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt3[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]       
        }
 
        if {[expr ($PFC_PRIORITY_NUMBER >= 5)]} {
        #enable tx + enable pfc + pfc num >4
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en4}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt4[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt4[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        }   

        if {[expr ($PFC_PRIORITY_NUMBER >= 6)]} {
        #enable tx + enable pfc + pfc num >5
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en5}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt5[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt5[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        }   

        if {[expr ($PFC_PRIORITY_NUMBER >= 7)]} {
        #enable tx + enable pfc + pfc num >6
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en6}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt6[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt6[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 8)]} {
        #enable tx + enable pfc + pfc num >7
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_en7}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_pfcfrm_pqt7[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|tx_xoff_hqt7[*]}] -to [get_registers {*alt_em10g32_tx_top:tx_path.tx_top_inst|*}]
        }
    
    }

}



if {[expr ($DATAPATH_OPTION == 2)] || [expr ($DATAPATH_OPTION == 3)]} {
#enable rx
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_crcpad_rem[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_allucast_en}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_allmcast_en}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_fwd_ctlfrm}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_fwd_pausefrm}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_ignore_pausefrm}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_max_datafrmlen[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rxvlandet_dis}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]

    if {[expr ($PREAMBLE_PASSTHROUGH == 1)]} {
    #enable rx and preamble pass through
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_preamb_passthru_en}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_preambctl_fwd}] -to [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_clock_crosser:clock_crosser_rx_clk_pulse_rx_pkt_ovrflw_errcnt|*}]
    }
 
    if {[expr ($ENABLE_SUPP_ADDR == 1)]} {
    #enable rx and supplement address
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_suppaddr_en0}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_suppaddr_en1}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_suppaddr_en2}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_suppaddr_en3}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit31to0_0[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit47to32_0[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit31to0_1[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit47to32_1[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit31to0_2[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit47to32_2[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit31to0_3[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_supp_macaddr_bit47to32_3[*]}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
    
    } 

    if {[expr ($ENABLE_PFC == 1)]} {
    #enable rx + pfc
    set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_fwd}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]   
    

        if {[expr ($PFC_PRIORITY_NUMBER >= 2)]} {
        #enable rx + pfc + pfc num >0
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_0}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]

        #enable rx + pfc + pfc num >1
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_1}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        }
    
        if {[expr ($PFC_PRIORITY_NUMBER >= 3)]} {
        #enable rx + pfc + pfc num >2
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_2}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 4)]} {
        #enable rx + pfc + pfc num >3
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_3}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 5)]} {
        #enable rx + pfc + pfc num >4
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_4}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 6)]} {
        #enable rx + pfc + pfc num >5
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_5}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 7)]} {
        #enable rx + pfc + pfc num >6
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_6}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        }
        
        if {[expr ($PFC_PRIORITY_NUMBER >= 8)]} {
        #enable rx + pfc + pfc num >7
        set_false_path -from [get_registers {*alt_em10g32_creg_top:creg_top_inst|alt_em10g32_creg_map:alt_em10g32_creg_map_inst|rx_pfc_ignore_pausefrm_7}] -to [get_registers {*alt_em10g32_rx_top:rx_path.rx_top_inst|*}]
        }
    
    }

}

set_project_mode -always_show_entity_name $old_mode
 9 0 2 C: 7 gitwork 19 LL10G_Cyclone10GX_1 3 rtl 3 phy 15 alt_usxgmii_phy 19 alt_mge_phy_pcs_181 5 synth 26 alt_mge_phy_usxg32_pcs.sdc 18915 # (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set old_mode [set_project_mode -get_mode_value always_show_entity_name] 
set_project_mode -always_show_entity_name on

# Function to constraint non-std_synchronizer path
proc alt_mge_phy_usxg32_pcs_constraint_net_delay {from_reg to_reg max_net_delay {check_exist 0}} {
    
    # Check for instances
    set inst [get_registers -nowarn ${to_reg}]
    
    # Check number of instances
    set inst_num [llength [query_collection -report -all $inst]]
    if {$inst_num > 0} {
        # Uncomment line below for debug purpose
        #puts "${inst_num} ${to_reg} instance(s) found"
    } else {
        # Uncomment line below for debug purpose
        #puts "No ${to_reg} instance found"
    }
    
    if {($check_exist == 0) || ($inst_num > 0)} {
        if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
            set_max_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] 200ns
            set_min_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] -200ns
        } else {
            set_net_delay -from [get_pins -compatibility_mode ${from_reg}|q] -to [get_registers ${to_reg}] -max $max_net_delay
            
            # Relax the fitter effort
            set_max_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] 200ns
            set_min_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] -200ns
        }
    }
}

# Function to constraint std_synchronizer
proc alt_mge_phy_usxg32_pcs_constraint_std_sync {} {
   
    alt_mge_phy_usxg32_pcs_constraint_net_delay  *  *alt_mge_phy_usxg32_pcs:*|alt_mge16_pcs_std_synchronizer:*|altera_std_synchronizer_nocut:*|din_s1  2.2ns
   
}

# Function to constraint pointers
proc alt_mge_phy_usxg32_pcs_constraint_ptr {from_path from_reg to_path to_reg max_skew max_net_delay} {
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${from_path}|${from_reg}\[0\]]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${from_path}|${from_reg} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${from_path}|${from_reg} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
        foreach_in_collection each_inst_tmp $inst {
            set each_inst [get_node_info -name $each_inst_tmp]
            
            # Get the path to instance
            regexp "(.*${from_path})(.*|)(${from_reg})" $each_inst reg_path inst_path inst_name reg_name
            
            set_max_skew -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] $max_skew
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -200ns
        }
        
    } else {
        set_net_delay -from [get_pins -compatibility_mode *${from_path}|${from_reg}[*]|q] -to [get_registers *${to_path}|${to_reg}*] -max $max_net_delay
        
        # Relax the fitter effort
        set_max_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 200ns
        set_min_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -200ns
        
    }
    
}

# Function to constraint clock crosser
proc alt_mge_phy_usxg32_pcs_constraint_clock_crosser {} {
    set module_name alt_mge16_pcs_clock_crosser
    
    set from_reg1 in_data_toggle
    set to_reg1 alt_mge16_pcs_std_synchronizer:in_to_out_synchronizer|altera_std_synchronizer_nocut:*|din_s1
    
    set from_reg2 in_data_buffer
    set to_reg2 out_data_buffer
    
    set from_reg3 out_data_toggle_flopped
    set to_reg3 alt_mge16_pcs_std_synchronizer:out_to_in_synchronizer|altera_std_synchronizer_nocut:*|din_s1
    
    set max_skew 3ns
    
    set max_delay1 3ns
    set max_delay2 2ns
    set max_delay3 3ns
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${module_name}:*|${from_reg1}]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${module_name} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${module_name} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
        foreach_in_collection each_inst_tmp $inst {
            set each_inst [get_node_info -name $each_inst_tmp]
            
            # Get the path to instance
            regexp "(.*${module_name})(:.*|)(${from_reg1})" $each_inst reg_path inst_path inst_name reg_name
            
            # Check if unused data buffer get synthesized away
            set reg2_collection [get_registers -nowarn ${inst_path}${inst_name}${to_reg2}[*]]
            set reg2_num [llength [query_collection -report -all $reg2_collection]]
            
            if {$reg2_num > 0} {
                set_max_skew -from [get_registers "${inst_path}${inst_name}${from_reg1} ${inst_path}${inst_name}${from_reg2}[*]"] -to [get_registers "${inst_path}${inst_name}${to_reg1} ${inst_path}${inst_name}${to_reg2}[*]"] $max_skew
                
                set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] 200ns
                set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] -200ns
            }
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] -200ns
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg3}] -to [get_registers ${inst_path}${inst_name}${to_reg3}] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg3}] -to [get_registers ${inst_path}${inst_name}${to_reg3}] -200ns
        }
        
    } else {
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg1}|q]    -to [get_registers *${module_name}:*|${to_reg1}] -max $max_delay1
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg2}[*]|q] -to [get_registers *${module_name}:*|${to_reg2}[*]] -max $max_delay2
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg3}|q]    -to [get_registers *${module_name}:*|${to_reg3}] -max $max_delay3
        
        # Relax the fitter effort
        set_max_delay -from [get_registers *${module_name}:*|${from_reg1}] -to [get_registers *${module_name}:*|${to_reg1}] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg1}] -to [get_registers *${module_name}:*|${to_reg1}] -200ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] -200ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg3}] -to [get_registers *${module_name}:*|${to_reg3}] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg3}] -to [get_registers *${module_name}:*|${to_reg3}] -200ns
        
    }
    
}

# Function to constraint one way clock crosser
proc alt_mge_phy_usxg32_pcs_constraint_mbow_clock_crosser {} {
    set module_name alt_mge_phy_mbow_clock_crosser
    
    set from_reg1 in_transfer_valid
    set to_reg1 alt_mge16_pcs_std_synchronizer:sync_transfer_valid|altera_std_synchronizer_nocut:*|din_s1
    
    set from_reg2 in_data_buffer
    set to_reg2 out_data_buffer
    
    set max_skew 3ns
    
    set max_delay1 3ns
    set max_delay2 2ns
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${module_name}:*|${from_reg1}]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${module_name} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${module_name} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
        foreach_in_collection each_inst_tmp $inst {
            set each_inst [get_node_info -name $each_inst_tmp]
            
            # Get the path to instance
            regexp "(.*${module_name})(:.*|)(${from_reg1})" $each_inst reg_path inst_path inst_name reg_name
            
            # Check if unused data buffer get synthesized away
            set reg2_collection [get_registers -nowarn ${inst_path}${inst_name}${to_reg2}[*]]
            set reg2_num [llength [query_collection -report -all $reg2_collection]]
            
            if {$reg2_num > 0} {
                set_max_skew -from [get_registers "${inst_path}${inst_name}${from_reg1} ${inst_path}${inst_name}${from_reg2}[*]"] -to [get_registers "${inst_path}${inst_name}${to_reg1} ${inst_path}${inst_name}${to_reg2}[*]"] $max_skew
                
                set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] 200ns
                set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] -200ns
            }
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] -200ns
        }
        
    } else {
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg1}|q]    -to [get_registers *${module_name}:*|${to_reg1}] -max $max_delay1
        set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg2}[*]|q] -to [get_registers *${module_name}:*|${to_reg2}[*]] -max $max_delay2
        
        # Relax the fitter effort
        set_max_delay -from [get_registers *${module_name}:*|${from_reg1}] -to [get_registers *${module_name}:*|${to_reg1}] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg1}] -to [get_registers *${module_name}:*|${to_reg1}] -200ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] 200ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] -200ns
        
    }
    
}

# Standard Synchronizer
alt_mge_phy_usxg32_pcs_constraint_std_sync

# Clock Crosser
alt_mge_phy_usxg32_pcs_constraint_clock_crosser

# One Way Clock Crosser
alt_mge_phy_usxg32_pcs_constraint_mbow_clock_crosser

# DC FIFO
alt_mge_phy_usxg32_pcs_constraint_ptr  alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_tx_clockcomp_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated  delayed_wrptr_g  alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_tx_clockcomp_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated|alt_synch_pipe_*:*|*  *dffe*  2.5ns  2.1ns
alt_mge_phy_usxg32_pcs_constraint_ptr  alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_tx_clockcomp_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated  rdptr_g          alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_tx_clockcomp_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated|alt_synch_pipe_*:*|*  *dffe*  2.5ns  2.1ns
alt_mge_phy_usxg32_pcs_constraint_ptr  alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated  delayed_wrptr_g    alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated|alt_synch_pipe_*:*|*  *dffe*  2.5ns  2.1ns
alt_mge_phy_usxg32_pcs_constraint_ptr  alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated  rdptr_g            alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:async_fifo|dcfifo:dcfifo_componenet|dcfifo_*:auto_generated|alt_synch_pipe_*:*|*  *dffe*  2.5ns  2.1ns

# Reset
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain_out] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_tx_clockcomp_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*rdaclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain_out] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_tx_clockcomp_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*wraclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain_out] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*rdaclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain_out] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*wraclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|cur_data_in[36]] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*wraclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|cur_data_in[36]] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*rdaclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge16_pcs_std_synchronizer:bitsync_block_lock|altera_std_synchronizer_nocut:*|dreg[0]] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*wraclr*|clrn]
set_false_path -from [get_registers -nowarn *alt_mge_phy_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge16_pcs_std_synchronizer:bitsync_block_lock|altera_std_synchronizer_nocut:*|dreg[0]] -to [get_pins -compatibility_mode -nocase *alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_rx_rm_fifo:*|alt_mge_phy_async_fifo_fpga:*|dcfifo:dcfifo_componenet|*rdaclr*|clrn]

# Operating Speed
set_false_path -from [get_registers {*alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_an_top:*|an_done}] -to [get_registers {*alt_mge_phy_usxg32_pcs:*|operating_speed*}]
set_false_path -from [get_registers {*alt_mge_phy_usxg32_pcs:*|alt_mge_phy_usxg32_an_top:*|lp_ability*}] -to [get_registers {*alt_mge_phy_usxg32_pcs:*|operating_speed*}]
set_false_path -from [get_registers {*alt_mge_phy_usxg32_pcs:*|operating_speed*}] -to [get_registers {*alt_mge_phy_usxg32_rx_top:*|*}]

#**************************************************************
# Set False Path for alt_mge16_pcs_reset_synchronizer
#**************************************************************
set reset_sync_aclr_counter 0
set reset_sync_clrn_counter 0
set reset_sync_aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain*|aclr]
set reset_sync_clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain*|clrn]

foreach_in_collection reset_sync_aclr_pin $reset_sync_aclr_collection {
    set reset_sync_aclr_counter [expr $reset_sync_aclr_counter + 1]
}

foreach_in_collection reset_sync_clrn_pin $reset_sync_clrn_collection {
    set reset_sync_clrn_counter [expr $reset_sync_clrn_counter + 1]
}

if {$reset_sync_aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain*|aclr]
}

if {$reset_sync_clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_mge16_pcs_reset_synchronizer:*|alt_mge16_pcs_reset_synchronizer_chain*|clrn]
}

set_project_mode -always_show_entity_name $old_mode
 1
